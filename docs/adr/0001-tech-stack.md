# ADR-0001: Выбор технологического стека

**Статус**: Принято (ACCEPTED)  
**Контекст**: Фронтенд веб-приложение для чтения и отображения Markdown контента с маршрутизацией.  
**Дата**: 2025-12-24

## Решение

### Выбранный стек
| Компонент | Технология | Версия |
|-----------|-----------|---------|
| **Runtime** | Node.js / npm | >=18.0.0 |
| **Фреймворк** | Vue.js | ^3.4.0 |
| **Маршрутизация** | Vue Router | ^4.3.0 |
| **Язык** | TypeScript | ^5.5.0 |
| **Стилизация** | Tailwind CSS | ^4.0.0 |
| **Сборка** | Vite | ^5.0.0 |
| **Линтинг** | ESLint | ^8.0.0 |
| **Форматирование** | Prettier | ^3.0.0 |
| **Парсинг Markdown** | marked | ^13.0.0 |
| **Парсинг frontmatter** | встроенный YAML парсер | - |

### Архитектурные решения

#### 1. **Загрузка Markdown контента с сохранением иерархии директорий**
**Подход**: Vite `import.meta.glob()` + рекурсивное сканирование + парсинг YAML frontmatter (gray-matter)  
**Почему**: 
- Все Markdown файлы упакованы в сборку (no HTTP запросов)
- Структура директорий (`content/blog/`, `content/docs/` и т.п.) сохраняется и доступна на клиенте
- Метаданные извлекаются из YAML frontmatter

```typescript
// src/utils/markdown.ts
const postModules = import.meta.glob<string>('/content/**/*.md', { as: 'raw' });

// Результат:
// {
//   '/content/blog/post-1.md': 'content...',
//   '/content/blog/post-2.md': 'content...',
//   '/content/docs/guide.md': 'content...'
// }

// Парсинг структуры директорий + метаданных:
// posts = [
//   {
//     path: 'blog/post-1',
//     dir: 'blog',
//     title: 'Заголовок',
//     content: '<h1>...</h1>'
//   }
// ]
```

**Альтернатива отклонена**: динамическая загрузка через fetch (усложняет build, нарушает SPA).

#### 2. **Отсутствие State Management**
**Решение**: Vue Composition API + Reactive API (ref, computed, provide/inject)  
**Почему**: Для простого SPA с локальным контентом избыточно. Pinia добавляет boilerplate без выгоды.

#### 3. **TypeScript**
**Решение**: Строгий режим (`strict: true`)  
**Почему**: Улучшает DX, ловит ошибки на этапе сборки, комфортная работа с Props/Emits в Vue компонентах.

#### 4. **Tailwind CSS v4**
**Решение**: CSS-первый подход, никакого JIT (встроено в Tailwind 4)  
**Почему**: Все CSS генерируется автоматически из классов в JSX/template, свежая версия с лучшей производительностью.

#### 5. **Сборка для deployment**
**Решение**: `npm run build` → `dist/` (готово к Nginx)  
**Почему**: Vite гарантирует минимизацию, tree-shaking, hash-based кеширование. Статика полностью готова к развёртыванию.

## Альтернативы, рассмотренные и отклонённые

| Альтернатива | Причина отклонения |
|--------------|-------------------|
| **Next.js / Nuxt** | Избыточно для SPA без SSR; усложняет build pipeline |
| **webpack** | Vite быстрее, проще конфиг, лучше DX |
| **Pinia / Vuex** | Не нужно для этого масштаба; Vue Reactive API достаточно |
| **Jest / Vitest** | Тесты не требуются в Acceptance Criteria |
| **Tailwind v3** | v4 улучшена производительность, лучше интеграция |

## Последствия (Trade-offs)

### Positive
✅ Быстрый старт (Vite = instant HMR)  
✅ Минимальный boilerplate  
✅ TypeScript для типобезопасности  
✅ Всё упаковано в один/несколько JS файлов (легко деплоить)  

### Risks & Миtigations
⚠️ **Масштабируемость**: если контент растёт > 1MB, добавить code-splitting по роутам  
⚠️ **SEO**: для SPA нужна предварительная генерация meta tags (если будет нужно)  
⚠️ **Производительность**: если markdown парсится на клиенте, кэшировать результаты через `computed()`

## Дальнейшие шаги (если потребуются)
1. Добавить SSG (Static Site Generation) через Vite для SEO оптимизации
2. Integrаate OpenGraph meta tags для social sharing
3. Lazy load больших Markdown файлов через dynamic imports
4. Добавить поиск контента (Lunr.js или мини-индекс)

